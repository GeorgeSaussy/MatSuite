\documentclass{article}

\usepackage{amssymb,amsmath,amsthm,amsfonts,bbm,accents,mathtools,dsfont}
\usepackage{upgreek}
\usepackage{courier}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{comment}
\usepackage{geometry}
\usepackage{graphicx,ctable,booktabs}
\usepackage[]{units}
\usepackage{setspace}
\usepackage{wrapfig}
\usepackage{tikz}
\usetikzlibrary{calc}

\newcommand{\lint}{\int\limits}
\newcommand{\dint}{\displaystyle\int}
\newcommand{\llim}{\lim\limits}
\newcommand{\lsum}{\sum\limits}
\newcommand{\clos}[1]{\overline{#1}}
\newcommand{\trans}[1]{#1^\top}
\def\mean#1{\left< #1 \right>}
\newcommand{\error}{\ensuremath{{}^{{}_{_\sim}}}}
\newcommand{\minus}{\ensuremath{{}^{{}_{_{{-}}}}}\!}

\DeclareMathOperator{\vol}{vol}
\DeclareMathOperator{\sinc}{sinc}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\osc}{osc}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\Ima}{Im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\trace}{tr}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
%
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\makeatletter
\renewcommand*\env@matrix[1][\arraystretch]{%
	\edef\arraystretch{#1}%
	\hskip -\arraycolsep
	\let\@ifnextchar\new@ifnextchar
	\array{*\c@MaxMatrixCols c}}
\makeatother

\newcommand*{\Value}{\frac{1}{2}x^2}%

\newtheoremstyle{exampstyle}
{} % Space above
{\parsep} % Space below
{} % Body font
{} % Indent amount
{\itshape} % Theorem head font
{.} % Punctuation after theorem head
{.5em} % Space after theorem head
{} % Theorem head spec (can be left empty, meaning `normal')
\theoremstyle{exampstyle} \newtheorem*{remark}{Remark}

\renewcommand{\complement}[1]{#1^\mathsf{c}}
\newcommand{\R}{\mathds{R}}
\newcommand{\N}{\mathds{N}}
\newcommand{\C}{\mathds{C}}
\newcommand{\Z}{\mathds{Z}}
\newcommand{\Q}{\mathds{Q}}
\newcommand{\D}{\mathds{D}}
\newcommand{\Hyp}{\mathds{H}}
\newcommand{\1}{\mathds{1}}
\newcommand{\e}{\mathds{E}}
\newcommand{\Id}{\mathrm{Id}}
\newcommand{\compcent}[1]{\vcenter{\hbox{$#1\circ$}}}
\newcommand{\comp}{\mathbin{\mathchoice
		{\compcent\scriptstyle}{\compcent\scriptstyle}
		{\compcent\scriptscriptstyle}{\compcent\scriptscriptstyle}}}

\providecommand*{\unit}[1]{\ensuremath{\mathrm{\,#1}}}

\makeatletter
\providecommand{\diff}%
{\@ifnextchar^{\DIfF}{\DIfF^{}}}
\def\DIfF^#1{ \mathop{\mathrm{\mathstrut d}} \nolimits^{#1}\gobblespace }
\def\gobblespace{\futurelet\diffarg\opspace}
\def\opspace{%
	\let\DiffSpace\!
	\ifx\diffarg( \let\DiffSpace\relax \else
	\ifx\diffarg\[ \let\DiffSpace\relax \else
	\ifx\diffarg\] \let\DiffSpace\relax \else
	\ifx\diffarg\{ \let\DiffSpace\relax \fi\fi\fi\DiffSpace}
\providecommand{\deriv}[3][]{ \frac{\diff^{#1}#2}{\diff #3^{#1}}}
\providecommand{\pderiv}[3][]{ \frac{\partial^{#1}#2}{\partial #3^{#1}}}

\newcommand{\dderiv}{\displaystyle\deriv}
\newcommand{\dpderiv}{\displaystyle\pderiv}

\begin{document}

\title{MatSuite Writeup}
\author{George Saussy}
\maketitle

In this project we attempt to build a GPU optimized implementation of Krylov wave propagation for quantum states. In the process we, implement a small suite of functions designed to handle matrices. This system will be used to train an neural network that will speed up the calculation of the propagation of quantum states. The neural network can then be used to aid in the design of molecules which would be computationally infeasible otherwise.

% 5 6 7 8 9 10

\section{Motivation}
Physicist must frequently calculate the propagation of a quantum state. This calculation is often extremely computationally expensive, even for simple systems. This problem is only exasperated when many bodies are introduced or the Hamiltonian is not well behaved. %3 

However, as physical methods play a greater role in chemistry, more efficient means of calculating wave propagation in many body systems must be explored. The aim of this research should be to bring down the cost of understanding the the behaviour of particles and molecules in generic settings, so that the methods found can be generally applied without needing to be customized for a given problem. %2

In the interest of generality the most generic form of a quantum system is given by the Schrodinger equation, $i\hbar d_t|\phi\rangle = H|\phi\rangle$, where $|\phi\rangle$ is the quantum state and $H$ is the Hamiltonian under which the system is evolving. The generic solution to this equation is then 
\[ |\phi (t)\rangle = \exp(-iHt/\hbar ) |\phi_0\rangle \]
However, this computation is practice is very expensive because of the exponential. In particular the generic definition of $\exp (A)$ for matrix $A$ is given by 
\[ \exp (A) = \sum_{k=0}^\infty A^k/k! \]
which does not converge quickly for $\norm{A}>>1$. % 5
(In fact, the error term given only a constant number of terms are used in the above equation will grow exponentially with $\norm{A}$.)
Bringing the computation time for matrix exponentiation down would allow theorists to consider systems with a greater set of pure quantum states, and potentially to numerically consider the behaviour of systems that were previously infeasible to treat. % 2

In this project, I present the design and implementation of a suite of GPU optimized software to speed up these computations. % 1

% 14 15

\section{Mathematical background}

% 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

\section{Project design}

(More detailed documentation for the suite can be found in the code. Run \texttt{doxygen} in the repository's home directory and a directory containing technical documentation in HTML will be generated.)

This project has two overall goals: 1) to create code that will perform wave propagation as efficiently as possible, and 2) to make this implementation as portable and easy to use as possible to use as possible. To that end, there will be four functions implemented, each representing different approximation methods.

The primary computational structure used in the program is a \texttt{struct SqMat}. This struct is a square matrix of real numbers, and the current implementation of the the library only supports real matrices. 
\newline

\texttt{double* expv(struct SqMat mat, double t, double * v, double tau, double minerr);}

A function to perform the the Krylov estimation for $\exp(t*mat)v$ where \texttt{tau} is the time step used and \texttt{minerr} is the minimum error allowed (must be greater than machine error on double operations). This algorithm is optimized for the case \texttt{mat} is large and sparse. (It is the user's responsibility ensure that $Dim(v)=\sqrt{Dim(mat)}$.)  
\newline

\texttt{struct SqMat expPade(struct SqMat mat, int p, int q);}

An implementation of an older algorithm to implement the p,q-Pade approximation for $\exp(mat)$. By default, $p=q=14$ should be used.  
\newline

\texttt{struct SqMat }
\texttt{struct SqMat expTaylor(struct SqMat mat, int k);}

An implementation of the Taylor approximation of 
$$\exp(mat)\approx\sum_{n=0}^k(mat)^n/n!$$
This should not be used in practice but is included for completion.
\newline

A small set of example programs demonstrating how the functions should be implemented in the near future.

% 9 10 11 12 13 14 15
\section{TODO}
The project now forks into two sub-project: 1) begin the GPU optimization process and 2) implement more features.

While GPU optimization is simple enough to understand, the practical steps are more finely detailed. As of now, we are tentatively considering using SPIR-V from the Vulkan API. The advantaged of this implementation over something like CUDA or OpenCL is that SPIR-V does not require the programmer to configure the the code for any possible computer architecture. SPIR-V allows the programmer to focus on higher level program design. One draw back on SPIR-V, especially in comparison to CUDA, is that the Vulkan API has not been generally accepted, so one older systems, the library may not run. (Vulkan is an API slotted to replace OpenGL, and SPIR-V is its GPU coding paradigm.)

The other direction, implementing more features, is more strait forward. First the structs \texttt{struct Complex} and \texttt{struct SqMatCplx} for complex numbers and complex matrices respectively. These will be used in a new implementation of the above functions. These new functions are absolutely necessary, as nearly all Hamiltonians are complex. (The decision to focus on real matrices first was to get a functioning implementation ready as soon as possible, even with limited functionality.) Of course once the functions are implemented, they will need to be GPU optimized as well, but this should be more strait forward as 

\section{Results}

$$ FORTHCOMING $$

\section{Discussion}

$$ FORTHCOMING $$

\end{document}
