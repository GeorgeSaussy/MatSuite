\documentclass{article}

\usepackage{amssymb,amsmath,amsthm,amsfonts,bbm,accents,mathtools,dsfont}
\usepackage{upgreek}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{comment}
\usepackage{geometry}
\usepackage{graphicx,ctable,booktabs}
\usepackage[]{units}
\usepackage{setspace}
\usepackage{wrapfig}
\usepackage{tikz}
\usetikzlibrary{calc}

\newcommand{\lint}{\int\limits}
\newcommand{\dint}{\displaystyle\int}
\newcommand{\llim}{\lim\limits}
\newcommand{\lsum}{\sum\limits}
\newcommand{\clos}[1]{\overline{#1}}
\newcommand{\trans}[1]{#1^\top}
\def\mean#1{\left< #1 \right>}
\newcommand{\error}{\ensuremath{{}^{{}_{_\sim}}}}
\newcommand{\minus}{\ensuremath{{}^{{}_{_{{-}}}}}\!}

\DeclareMathOperator{\vol}{vol}
\DeclareMathOperator{\sinc}{sinc}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\osc}{osc}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\Ima}{Im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\trace}{tr}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\makeatletter
\let\oldabs\abs
\def\abs{\@ifstar{\oldabs}{\oldabs*}}
%
\let\oldnorm\norm
\def\norm{\@ifstar{\oldnorm}{\oldnorm*}}
\makeatother

\makeatletter
\renewcommand*\env@matrix[1][\arraystretch]{%
	\edef\arraystretch{#1}%
	\hskip -\arraycolsep
	\let\@ifnextchar\new@ifnextchar
	\array{*\c@MaxMatrixCols c}}
\makeatother

\newcommand*{\Value}{\frac{1}{2}x^2}%

\newtheoremstyle{exampstyle}
{} % Space above
{\parsep} % Space below
{} % Body font
{} % Indent amount
{\itshape} % Theorem head font
{.} % Punctuation after theorem head
{.5em} % Space after theorem head
{} % Theorem head spec (can be left empty, meaning `normal')
\theoremstyle{exampstyle} \newtheorem*{remark}{Remark}

\renewcommand{\complement}[1]{#1^\mathsf{c}}
\newcommand{\R}{\mathds{R}}
\newcommand{\N}{\mathds{N}}
\newcommand{\C}{\mathds{C}}
\newcommand{\Z}{\mathds{Z}}
\newcommand{\Q}{\mathds{Q}}
\newcommand{\D}{\mathds{D}}
\newcommand{\Hyp}{\mathds{H}}
\newcommand{\1}{\mathds{1}}
\newcommand{\e}{\mathds{E}}
\newcommand{\Id}{\mathrm{Id}}
\newcommand{\compcent}[1]{\vcenter{\hbox{$#1\circ$}}}
\newcommand{\comp}{\mathbin{\mathchoice
		{\compcent\scriptstyle}{\compcent\scriptstyle}
		{\compcent\scriptscriptstyle}{\compcent\scriptscriptstyle}}}

\providecommand*{\unit}[1]{\ensuremath{\mathrm{\,#1}}}

\makeatletter
\providecommand{\diff}%
{\@ifnextchar^{\DIfF}{\DIfF^{}}}
\def\DIfF^#1{ \mathop{\mathrm{\mathstrut d}} \nolimits^{#1}\gobblespace }
\def\gobblespace{\futurelet\diffarg\opspace}
\def\opspace{%
	\let\DiffSpace\!
	\ifx\diffarg( \let\DiffSpace\relax \else
	\ifx\diffarg\[ \let\DiffSpace\relax \else
	\ifx\diffarg\] \let\DiffSpace\relax \else
	\ifx\diffarg\{ \let\DiffSpace\relax \fi\fi\fi\DiffSpace}
\providecommand{\deriv}[3][]{ \frac{\diff^{#1}#2}{\diff #3^{#1}}}
\providecommand{\pderiv}[3][]{ \frac{\partial^{#1}#2}{\partial #3^{#1}}}

\newcommand{\dderiv}{\displaystyle\deriv}
\newcommand{\dpderiv}{\displaystyle\pderiv}

\begin{document}

\title{MatSuite Writeup}
\author{George Saussy}
\maketitle

In this project we attempt to build a GPU optimized implementation of Krylov wave propagation for quantum states. In the process we, implement a small suite of functions designed to handle matrices. This system will be used to train an neural network that will speed up the calculation of the propagation of quantum states. The neural network can then be used to aid in the design of molecules which would be computationally infeasible otherwise.

% 5 6 7 8 9 10

\section{Motivation}
Physicist must frequently calculate the propagation of a quantum state. This calculation is often extremely computationally expensive, even for simple systems. This problem is only exasperated when many bodies are introduced or the Hamiltonian is not well behaved. %3 

However, as physical methods play a greater role in chemistry, more efficient means of calculating wave propagation in many body systems must be explored. The aim of this research should be to bring down the cost of understanding the the behaviour of particles and molecules in generic settings, so that the methods found can be generally applied without needing to be customized for a given problem. %2

In the interest of generality the most generic form of a quantum system is given by the Schrodinger equation, $i\hbar d_t|\phi\rangle = H|\phi\rangle$, where $|\phi\rangle$ is the quantum state and $H$ is the Hamiltonian under which the system is evolving. The generic solution to this equation is then 
\[ |\phi (t)\rangle = \exp(-iHt/\hbar ) |\phi_0\rangle \]
However, this computation is practice is very expensive because of the exponential. In particular the generic definition of $\exp (A)$ for matrix $A$ is given by 
\[ \exp (A) = \sum_{k=0}^\infty A^k/k! \]
which does not converge quickly for $\norm{A}>>1$. % 5
(In fact, the error term given only a constant number of terms are used in the above equation will grow exponentially with $\norm{A}$.)
Bringing the computation time for matrix exponentiation down would allow theorists to consider systems with a greater set of pure quantum states, and potentially to numerically consider the behaviour of systems that were previously infeasible to treat. % 2

In this project, I present the design and implementation of a suite of GPU optimized software to speed up these computations. % 1

% 14 15

\section{Mathematical background}

% 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

\section{Project design}

% 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

\section{Results}

$$ FORTHCOMING $$

\section{Discussion}

$$ FORTHCOMING $$

\end{document}
